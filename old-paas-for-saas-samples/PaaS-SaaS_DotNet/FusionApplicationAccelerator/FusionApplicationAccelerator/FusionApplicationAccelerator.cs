using System;
using System.Linq;

using System.Text;
using System.ServiceModel.Channels;
using System.ServiceModel;
using System.Net;
using FusionApplicationAccelerator.ActivityServiceReference;
using FusionApplicationAccelerator.OpportunityServiceReference;
using FusionApplicationAccelerator.PersonServiceReference;
using FusionApplicationAccelerator.ServiceCatalogServiceReference;
using FusionApplicationAccelerator.UserDetailsServiceReference;
using System.Web.Services.Description;
using System.Xml.Schema;
using System.Collections;
using System.Collections.Generic;
using System.Xml;
using System.ServiceModel.Dispatcher;
using System.IO;
/// This namespace contains sample logic on how to call FA services using .Net Service Reference
namespace FusionApplicationAccelerator
{

    /// <summary>
    /// Factory class that provides access to pre-generated clients to call a service
    /// </summary>
    /// <remarks>
    /// This class contains simple methods to access clients that can be used to call a service. Services supported:
    ///   - ActivityService
    ///   - OpportunityService
    ///   - PersonService
    ///   - ServiceCatalogService
    ///   - UserDetailsService
    /// Additional services can be generated by navigating "Project -> Add Service Reference" and providing the WSDL URL for the service.
    /// Do note that custom binding need to be provided to the client in order to call Fusion Application services. 
    /// </remarks>
    public static class FaServiceFactory
    {
        /// <summary>
        /// Static method to obtain instance of the ActivityService
        /// </summary>
        /// <param name="binding">The binding that defines the how the. Currently 2 pre-defined bindings are provided 
        /// UsernameTokenOverSslBinding and UsernameTokenBinding. The binding used must match the OWSM policy defined on the service</param>
        /// <param name="endpointAddress">The URL of the endpoint that hosts the service</param>
        /// <param name="credentials">The credentials to be used to invoke the service</param>
        /// <returns>Instance of the ActivityService client</returns>
        public static ActivityServiceClient GetActivityServiceClient(System.ServiceModel.Channels.Binding binding, EndpointAddress endpointAddress, NetworkCredential credentials)
        {
            ActivityServiceClient client = new ActivityServiceClient(binding, endpointAddress);
            client.ClientCredentials.UserName.UserName = credentials.UserName;
            client.ClientCredentials.UserName.Password = credentials.Password;
            client.Endpoint.Behaviors.Add(new EmptyElementBehavior());
            return client;
        }

        /// <summary>
        /// Static method to obtain instance of the OpportunityService
        /// </summary>
        /// <param name="binding">The binding that defines the how the. Currently 2 pre-defined bindings are provided 
        /// UsernameTokenOverSslBinding and UsernameTokenBinding. The binding used must match the OWSM policy defined on the service</param>
        /// <param name="endpointAddress">The URL of the endpoint that hosts the service</param>
        /// <param name="credentials">The credentials to be used to invoke the service</param>
        /// <returns>Instance of the OpportunityService client</returns>
        public static OpportunityServiceClient GetOpportunityServiceClient(System.ServiceModel.Channels.Binding binding, EndpointAddress endpointAddress, NetworkCredential credentials)
        {
            OpportunityServiceClient client = new OpportunityServiceClient(binding, endpointAddress);
            client.ClientCredentials.UserName.UserName = credentials.UserName;
            client.ClientCredentials.UserName.Password = credentials.Password;
            client.Endpoint.Behaviors.Add(new EmptyElementBehavior());
            return client;
        }

        /// <summary>
        /// Static method to obtain instance of the PersonService
        /// </summary>
        /// <param name="binding">The binding that defines the how the. Currently 2 pre-defined bindings are provided 
        /// UsernameTokenOverSslBinding and UsernameTokenBinding. The binding used must match the OWSM policy defined on the service</param>
        /// <param name="endpointAddress">The URL of the endpoint that hosts the service</param>
        /// <param name="credentials">The credentials to be used to invoke the service</param>
        /// <returns>Instance of the PersonService client</returns>
        public static PersonServiceClient GetPersonServiceClient(System.ServiceModel.Channels.Binding binding, EndpointAddress endpointAddress, NetworkCredential credentials)
        {
            PersonServiceClient client = new PersonServiceClient(binding, endpointAddress);
            client.ClientCredentials.UserName.UserName = credentials.UserName;
            client.ClientCredentials.UserName.Password = credentials.Password;
            client.Endpoint.Behaviors.Add(new EmptyElementBehavior());
            return client;
        }

        /// <summary>
        /// Static method to obtain instance of the ServiceCatalogService
        /// </summary>
        /// <param name="binding">The binding that defines the how the. Currently 2 pre-defined bindings are provided 
        /// UsernameTokenOverSslBinding and UsernameTokenBinding. The binding used must match the OWSM policy defined on the service</param>
        /// <param name="endpointAddress">The URL of the endpoint that hosts the service</param>
        /// <param name="credentials">The credentials to be used to invoke the service</param>
        /// <returns>Instance of the ServiceCatalogService client</returns>
        public static ServiceCatalogServiceClient GetServiceCatalogServiceClient(System.ServiceModel.Channels.Binding binding, EndpointAddress endpointAddress, NetworkCredential credentials)
        {
            ServiceCatalogServiceClient client = new ServiceCatalogServiceClient(binding, endpointAddress);
            client.ClientCredentials.UserName.UserName = credentials.UserName;
            client.ClientCredentials.UserName.Password = credentials.Password;
            client.Endpoint.Behaviors.Add(new EmptyElementBehavior());
            return client;
        }

        /// <summary>
        /// Static method to obtain instance of the UserDetailsService
        /// </summary>
        /// <param name="binding">The binding that defines the how the. Currently 2 pre-defined bindings are provided 
        /// UsernameTokenOverSslBinding and UsernameTokenBinding. The binding used must match the OWSM policy defined on the service</param>
        /// <param name="endpointAddress">The URL of the endpoint that hosts the service</param>
        /// <param name="credentials">The credentials to be used to invoke the service</param>
        /// <returns>Instance of the UserDetailsService client</returns>
        public static UserDetailsServiceClient GetUserDetailsServiceClient(System.ServiceModel.Channels.Binding binding, EndpointAddress endpointAddress, NetworkCredential credentials)
        {
            UserDetailsServiceClient client = new UserDetailsServiceClient(binding, endpointAddress);
            client.ClientCredentials.UserName.UserName = credentials.UserName;
            client.ClientCredentials.UserName.Password = credentials.Password;
            client.Endpoint.Behaviors.Add(new EmptyElementBehavior());
            return client;
        }
    }

    /// <summary>
    /// Custom binding that can be used to invoke Fusion Application services secured with OWSM policy
    /// </summary>
    /// <remarks>
    /// This custom binding can be used to invoke Fusion Application services secured with 
    /// "oracle/wss_username_token_over_ssl_service_policy" OWSM policy
    /// </remarks>
    public class UsernameTokenOverSslBinding : CustomBinding
    {
        public override BindingElementCollection CreateBindingElements()
        {
            BindingElementCollection bindingElements = new BindingElementCollection();
            bindingElements.Add(SecurityBindingElement.CreateUserNameOverTransportBindingElement());
            MtomMessageEncodingBindingElement messageEncoding = new MtomMessageEncodingBindingElement();
            messageEncoding.MessageVersion = MessageVersion.Soap11;
            bindingElements.Add(messageEncoding);
            HttpsTransportBindingElement transport = new HttpsTransportBindingElement();
            transport.ManualAddressing = false;
            transport.AllowCookies = false;
            transport.AuthenticationScheme = AuthenticationSchemes.Anonymous;
            transport.BypassProxyOnLocal = false;
            transport.DecompressionEnabled = true;
            transport.HostNameComparisonMode = HostNameComparisonMode.StrongWildcard;
            transport.KeepAliveEnabled = true;
            transport.ProxyAuthenticationScheme = AuthenticationSchemes.Anonymous;
            transport.TransferMode = TransferMode.Buffered;
            transport.UnsafeConnectionNtlmAuthentication = false;
            transport.UseDefaultWebProxy = true;
            bindingElements.Add(transport);
            return bindingElements.Clone();
        }
    }

    /// <summary>
    /// Custom binding that can be used to invoke Fusion Application services secured with OWSM policy
    /// </summary>
    /// <remarks>
    /// This custom binding can be used to invoke Fusion Application services secured with 
    /// "oracle/wss_username_token_client_policy" OWSM policy
    /// </remarks>
    public class UsernameTokenBinding : CustomBinding
    {
        public override BindingElementCollection CreateBindingElements()
        {
            BindingElementCollection bindingElements = new BindingElementCollection();
            TransportSecurityBindingElement security = SecurityBindingElement.CreateUserNameOverTransportBindingElement();
            security.IncludeTimestamp = false;
            bindingElements.Add(security);
            TextMessageEncodingBindingElement messageEncoding = new TextMessageEncodingBindingElement();
            messageEncoding.MessageVersion = MessageVersion.Soap11;
            bindingElements.Add(messageEncoding);
            HttpsTransportBindingElement transport = new HttpsTransportBindingElement();
            transport.MaxReceivedMessageSize = int.MaxValue;
            transport.ManualAddressing = false;
            transport.AllowCookies = false;
            transport.AuthenticationScheme = AuthenticationSchemes.Anonymous;
            transport.BypassProxyOnLocal = false;
            transport.DecompressionEnabled = true;
            transport.HostNameComparisonMode = HostNameComparisonMode.StrongWildcard;
            transport.KeepAliveEnabled = true;
            transport.ProxyAuthenticationScheme = AuthenticationSchemes.Anonymous;
            transport.TransferMode = TransferMode.Buffered;
            transport.UnsafeConnectionNtlmAuthentication = false;
            transport.UseDefaultWebProxy = true;
            bindingElements.Add(transport);
            return bindingElements.Clone();
        }
    }

    /// <summary>
    /// Factory class that provides access to custom bindings that can be used to call Fusion Application services
    /// </summary>
    /// <remarks>
    /// This class contains simple methods to access obtain custom bindings matching OWSM policies 
    /// used to secure services. Policies supported:
    ///   - oracle/wss_username_token_over_ssl_service_policy
    ///   - oracle/wss_username_token_client_policy
    /// </remarks>
    public static class FaBindingFactory
    {
        /// <summary>
        /// Get binding that can be used to call services secured with OWSM policy "oracle/wss_username_token_client_policy"
        /// </summary>
        /// <returns>Binding matching OWSM policy "oracle/wss_username_token_client_policy"</returns>
        public static System.ServiceModel.Channels.Binding GetUsernameTokenBinding()
        {
            return new UsernameTokenBinding();
        }

        /// <summary>
        /// Get binding that can be used to call services secured with OWSM policy "oracle/wss_username_token_over_ssl_service_policy"
        /// </summary>
        /// <returns>Binding matching OWSM policy "oracle/wss_username_token_over_ssl_service_policy"</returns>
        public static System.ServiceModel.Channels.Binding GetUsernameTokenOverSslBinding()
        {
            return new UsernameTokenOverSslBinding();
        }
    }

    /// <summary>
    /// This class provides convenience methods to get information for a service based on a WSDL document
    /// </summary>
    public class FaServiceHelper
    {
        ServiceDescription serviceDescription = null;
        XmlSchemaSet schemaSet = null;

        /// <summary>
        /// Initializes schema set for a service definition
        /// </summary>
        private void initSchemaSet()
        {
            if (null == schemaSet)
            {
                List<string> parameters = new List<string>();
                Types types = serviceDescription.Types;

                System.Xml.Schema.XmlSchema xmlSchema = types.Schemas[0];
                schemaSet = new XmlSchemaSet();
                schemaSet.Add(xmlSchema);
                schemaSet.Compile();
            }
        }

        /// <summary>
        /// Constructor for the class parsing the WSDL document
        /// </summary>
        /// <param name="wsdl">The URL for the WSDL for the service to be processed</param>
        public FaServiceHelper(string wsdl)
        {
            HttpWebRequest request = (HttpWebRequest)HttpWebRequest.Create(wsdl);
            HttpWebResponse response = (HttpWebResponse)request.GetResponse();
            System.IO.Stream stream = response.GetResponseStream();
            serviceDescription = ServiceDescription.Read(stream);
            initSchemaSet();
        }

        /// <summary>
        /// Get list of Operations defined for the service
        /// </summary>
        /// <returns>List of Operations for the service</returns>
        public Operation[] GetOperations()
        {
            Operation[] result = null;
            ArrayList operations = new ArrayList();
            PortTypeCollection portTypeCollection = serviceDescription.PortTypes;
            foreach (PortType portType in portTypeCollection)
            {
                OperationCollection operationCollection = portType.Operations;
                foreach (Operation operation in operationCollection)
                {
                    operations.Add(operation);
                }
            }
            if (operations.Count > 0)
            {
                result = new Operation[operations.Count];
                operations.CopyTo(result, 0);
            }
            return result;
        }

        /// <summary>
        /// Get Operation matching a specific name
        /// </summary>
        /// <param name="operationName">The name of the Operation to be fetched</param>
        /// <returns>Operation matching a specific name</returns>
        public Operation GetOperation(string operationName)
        {
            Operation result = null;
            Operation[] operations = GetOperations();
            foreach (Operation operation in operations)
            {
                if (operationName.Equals(operation.Name))
                {
                    result = operation;
                    break;
                }
            }
            return result;
        }

        /// <summary>
        /// Get the type(s) for a given element
        /// </summary>
        /// <param name="target">The element for which to obtain the type</param>
        /// <returns>The type(s) for a given element </returns>
        public XmlSchemaElement[] findTypes(XmlQualifiedName target)
        {
            XmlSchemaElement[] result = null;
            ArrayList elements = new ArrayList();
            XmlSchemaObjectTable globalTypes = schemaSet.GlobalTypes;
            XmlSchemaType targetType = globalTypes[target] as XmlSchemaType;
            if (null != targetType)
            {
                if (targetType is XmlSchemaComplexType)
                {
                    XmlSchemaComplexType targetComplexType = targetType as XmlSchemaComplexType;
                    XmlSchemaSequence sequence = targetComplexType.ContentTypeParticle as XmlSchemaSequence;

                    foreach (XmlSchemaElement childElement in sequence.Items)
                    {
                        elements.Add(childElement);
                    }
                }
            }
            if (elements.Count > 0)
            {
                result = new XmlSchemaElement[elements.Count];
                elements.CopyTo(result, 0);
            }
            return result;
        }

        /// <summary>
        /// Get input parameters for a given Operation
        /// </summary>
        /// <param name="operation">Operation for which to fetch the input parameters</param>
        /// <returns>List of input parameter elements</returns>
        public XmlSchemaElement[] GetInputParameters(Operation operation)
        {
            XmlSchemaElement[] result = null;
            ArrayList elements = new ArrayList();
            foreach (var message in operation.Messages)
            {
                if (message is OperationInput)
                {
                    foreach (System.Web.Services.Description.Message messagePart in serviceDescription.Messages)
                    {
                        if (messagePart.Name != ((OperationMessage)message).Message.Name) continue;

                        foreach (MessagePart part in messagePart.Parts)
                        {
                            XmlSchemaElement[] temp = GetParameterElements(part.Element);
                            if (null != temp)
                            {
                                elements.AddRange(temp);
                            }
                        }
                    }
                }
            }
            if (elements.Count > 0)
            {
                result = new XmlSchemaElement[elements.Count];
                elements.CopyTo(result, 0);
            }
            return result;
        }

        /// <summary>
        /// Get output parameters for a given Operation
        /// </summary>
        /// <param name="operation">Operation for which to fetch the output parameters</param>
        /// <returns>List of output parameter elements</returns>
        public XmlSchemaElement[] GetOutputParameters(Operation operation)
        {
            XmlSchemaElement[] result = null;
            ArrayList elements = new ArrayList();
            foreach (var message in operation.Messages)
            {
                if (message is OperationOutput)
                {
                    foreach (System.Web.Services.Description.Message messagePart in serviceDescription.Messages)
                    {
                        if (messagePart.Name != ((OperationMessage)message).Message.Name) continue;

                        foreach (MessagePart part in messagePart.Parts)
                        {
                            XmlSchemaElement[] temp = GetParameterElements(part.Element);
                            if (null != temp)
                            {
                                elements.AddRange(temp);
                            }
                        }
                    }

                }
            }
            if (elements.Count > 0)
            {
                result = new XmlSchemaElement[elements.Count];
                elements.CopyTo(result, 0);
            }
            return result;
        }

        /// <summary>
        /// Get the XSD element for a given parameter
        /// </summary>
        /// <param name="target">The input / output message for which to fetch the parameter</param>
        /// <returns>The XSD element for the input / output message</returns>
        private XmlSchemaElement[] GetParameterElements(XmlQualifiedName target)
        {
            XmlSchemaElement[] result = null;
            ArrayList elements = new ArrayList();
            XmlSchemaObjectTable globalElements = schemaSet.GlobalElements;
            XmlSchemaElement targetElement = globalElements[target] as XmlSchemaElement;
            if (null != targetElement)
            {
                XmlSchemaType schemaType = targetElement.SchemaType;
                XmlSchemaComplexType schemaComplexType = schemaType as XmlSchemaComplexType;

                if (schemaComplexType != null)
                {
                    XmlSchemaParticle particle = schemaComplexType.Particle;
                    XmlSchemaSequence sequence = particle as XmlSchemaSequence;

                    if (sequence != null)
                    {
                        foreach (XmlSchemaElement childElement in sequence.Items)
                        {
                            elements.Add(childElement);
                        }
                    }
                }
            }
            if (elements.Count > 0)
            {
                result = new XmlSchemaElement[elements.Count];
                elements.CopyTo(result, 0);
            }
            return result;
        }
    }

    /// <summary>
    /// This is a class used for custom processing removing empty elements from the WS response 
    /// </summary>
    /// <remarks>
    /// Calls to FA services include elements with no value are included in the response when the , this
    /// will cause the .Net de-serialization to fail for non-string data types. For example element defined as:
    ///   <xsd:element name="PrimaryContactPartyId" type="xsd:long" minOccurs="0" sdoXML:dataType="sdoJava:LongObject"/> 
    ///
    /// The response may contain an empty value:
    ///   <ns3:PrimaryContactPartyId/>'
    /// 
    /// Which causes exception:
    ///   Error in deserializing body of reply message for operation 'findOpportunity'. 
    ///   
    ///  .Net de-serialization expects "nillable="true"" to be defined for empty elements and since that is not
    ///  included the error occurs. This class is used to manipulate the response received from the service before
    ///  de-serialization by removing empty elements from the response. The element is removed from the reponse if
    ///  all of the following criteria are met:
    ///    - Node Type is XmlNodeType.Element 
    ///    - The element does NOT have any children
    ///    - The element has no content
    ///    - The element has no attributes
    /// </remarks>
    public class EmptyElementInspector : IClientMessageInspector
    {
        /// <summary>
        /// This will parse the response received from the service and remove all empty elements from it
        /// </summary>
        public void AfterReceiveReply(ref System.ServiceModel.Channels.Message reply, object correlationState)
        {
            MemoryStream memoryStream = new MemoryStream();
            XmlWriter xmlWriter = XmlWriter.Create(memoryStream);
            reply.WriteMessage(xmlWriter);
            xmlWriter.Flush();
            memoryStream.Position = 0;
            XmlDocument xmlDocument = new XmlDocument();
            xmlDocument.Load(memoryStream);

            XmlNamespaceManager xmlNamespaceManager = new XmlNamespaceManager(xmlDocument.NameTable);
            xmlNamespaceManager.AddNamespace("env", "http://schemas.xmlsoap.org/soap/envelope/");
            XmlNode header = xmlDocument.SelectSingleNode("//env:Header", xmlNamespaceManager);
            if (header != null)
            {
                header.ParentNode.RemoveChild(header);
            }

            XmlNodeList nodes = xmlDocument.SelectNodes("//node()");
            foreach (XmlNode node in nodes)
            {
                if (node.NodeType == XmlNodeType.Element && node.ChildNodes.Count == 0 && node.InnerXml == "" && node.Attributes.Count == 0)
                {
                    node.ParentNode.RemoveChild(node);
                }
            }
            memoryStream = new MemoryStream();
            xmlDocument.Save(memoryStream);
            memoryStream.Position = 0;
            XmlReader xmlReader = XmlReader.Create(memoryStream);
            System.ServiceModel.Channels.Message newMessage = System.ServiceModel.Channels.Message.CreateMessage(xmlReader, int.MaxValue, reply.Version);
            newMessage.Headers.CopyHeadersFrom(reply.Headers);
            newMessage.Properties.CopyProperties(reply.Properties);
            reply = newMessage;
        }

        public object BeforeSendRequest(ref System.ServiceModel.Channels.Message request, System.ServiceModel.IClientChannel channel)
        {
            return null;
        }
    }

    /// <summary>
    /// This class is used to add the custom inspector to process the response before de-serialization
    /// </summary>
    public class EmptyElementBehavior : System.ServiceModel.Description.IEndpointBehavior
    {
        public void AddBindingParameters(System.ServiceModel.Description.ServiceEndpoint endpoint, BindingParameterCollection bindingParameters)
        {

            //no-op
        }

        public void ApplyClientBehavior(System.ServiceModel.Description.ServiceEndpoint endpoint, ClientRuntime clientRuntime)
        {
            EmptyElementInspector inspector = new EmptyElementInspector();
            clientRuntime.MessageInspectors.Add(inspector);
        }

        public void ApplyDispatchBehavior(System.ServiceModel.Description.ServiceEndpoint endpoint, EndpointDispatcher endpointDispatcher)
        {
            //no-op
        }

        public void Validate(System.ServiceModel.Description.ServiceEndpoint endpoint)
        {
            //no-op
        }
    }
}
